{"ast":null,"code":"import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n  constructor(_callback) {\n    let _async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let _partSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1048576;\n    this._callback = _callback;\n    this._async = _async;\n    this._partSize = _partSize;\n    this._configureReader();\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   */\n  hash(blob) {\n    const self = this;\n    self._blob = blob;\n    // self._length = Math.ceil(blob.size / self._partSize);\n    self._part = 0;\n    self._md5 = new Md5();\n    self._processPart();\n  }\n  _fail() {\n    this._callback({\n      success: false,\n      result: 'data read failed'\n    });\n  }\n  _hashData(e) {\n    let self = this;\n    self._md5.appendByteArray(new Uint8Array(e.target.result));\n    if (self._part * self._partSize >= self._blob.size) {\n      self._callback({\n        success: true,\n        result: self._md5.end()\n      });\n    } else {\n      self._processPart();\n    }\n  }\n  _processPart() {\n    const self = this;\n    let endbyte = 0;\n    let current_part;\n    self._part += 1;\n    if (self._blob.size > self._partSize) {\n      // If blob bigger then part_size we will slice it up\n      endbyte = self._part * self._partSize;\n      if (endbyte > self._blob.size) {\n        endbyte = self._blob.size;\n      }\n      current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n    } else {\n      current_part = self._blob;\n    }\n    if (self._async) {\n      self._reader.readAsArrayBuffer(current_part);\n    } else {\n      setTimeout(() => {\n        try {\n          self._hashData({\n            target: {\n              result: self._reader.readAsArrayBuffer(current_part)\n            }\n          });\n        } catch (e) {\n          self._fail();\n        }\n      }, 0);\n    }\n  }\n  _configureReader() {\n    const self = this;\n    if (self._async) {\n      self._reader = new FileReader();\n      self._reader.onload = self._hashData.bind(self);\n      self._reader.onerror = self._fail.bind(self);\n      self._reader.onabort = self._fail.bind(self);\n    } else {\n      self._reader = new FileReaderSync();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Md5","Md5FileHasher","constructor","_callback","_async","_partSize","_configureReader","hash","blob","self","_blob","_part","_md5","_processPart","_fail","success","result","_hashData","e","appendByteArray","Uint8Array","target","size","end","endbyte","current_part","slice","_reader","readAsArrayBuffer","setTimeout","FileReader","onload","bind","onerror","onabort","FileReaderSync"],"sources":["/home/tayrocha/Documentos/Estudos/frontend/node_modules/ts-md5/src/md5_file_hasher.ts"],"sourcesContent":["import {Md5} from './md5';\n\ndeclare let FileReaderSync: any;\n\nexport interface HashingResponse {\n    success: boolean;\n    result?: string | Int32Array;\n}\n\n// Hashes any blob\nexport class Md5FileHasher {\n    private _reader: any;\n\n    private _md5!: Md5;\n    private _part!: number;\n    // private _length!: number;\n    private _blob: any;\n\n\n    constructor(\n        private _callback: (r: HashingResponse) => void,    // Callback to return the result\n        private _async: boolean = true,                     // Async version is not always available in a web worker\n        private _partSize: number = 1048576,                // 1mb\n    ) {\n        this._configureReader();\n    }\n\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     */\n    public hash(blob: any) {\n        const self = this;\n\n        self._blob = blob;\n        // self._length = Math.ceil(blob.size / self._partSize);\n        self._part = 0;\n        self._md5 = new Md5();\n        self._processPart();\n    }\n\n\n    private _fail() {\n        this._callback({\n            success: false,\n            result: 'data read failed'\n        });\n    }\n\n    private _hashData(e: any) {\n        let self = this;\n\n        self._md5.appendByteArray(new Uint8Array(e.target.result));\n        if (self._part * self._partSize >= self._blob.size) {\n            self._callback({\n                success: true,\n                result: self._md5.end()\n            });\n        } else {\n            self._processPart();\n        }\n    }\n\n    private _processPart() {\n        const self = this;\n        let endbyte = 0;\n        let current_part: any;\n\n        self._part += 1;\n\n        if (self._blob.size > self._partSize) {        // If blob bigger then part_size we will slice it up\n            endbyte = self._part * self._partSize;\n            if (endbyte > self._blob.size) {\n                endbyte = self._blob.size;\n            }\n            current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n        } else {\n            current_part = self._blob;\n        }\n\n        if (self._async) {\n            self._reader.readAsArrayBuffer(current_part);\n        } else {\n            setTimeout(() => {\n                try {\n                    self._hashData({\n                        target: {\n                            result: self._reader.readAsArrayBuffer(current_part)\n                        },\n                    });\n                } catch (e) {\n                    self._fail();\n                }\n            }, 0);\n        }\n    }\n\n    private _configureReader() {\n        const self = this;\n\n        if (self._async) {\n            self._reader = new FileReader();\n            self._reader.onload = self._hashData.bind(self);\n            self._reader.onerror = self._fail.bind(self);\n            self._reader.onabort = self._fail.bind(self);\n        } else {\n            self._reader = new FileReaderSync();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}